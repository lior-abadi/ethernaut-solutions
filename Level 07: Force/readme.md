## 1) Catch
This level forces you to learn how tokens are transfered on the Ethereum Blockchain in some "emergency" or "non common" scenarios. To crack this level it is key to think about the existance of smart contracts and their lifespan on the blockchain.


## 2) Solution
In here, even if low level functions that transfer ether are tried to excecute, the transaction attempt will be reverted. Technically, there are two ways to force ether into a contract that lacks of a fallback payable fuction. We will address both of them.

The achievable solutions are the following:
- Selfdesctruct a contract and set its tokens to be sent to the empty contract.
- Predestinate the empty contract address and send tokens to that address **before** creating the instance.

### Selfdestruction
You can excecute the ```selfdestruct(address _inheritor)``` and the existing balance of the kamikaze contract will be inmediatly sent to the inheritor.

This solution is addressed by creating the ```SolutionA07.sol```. 
- First you need to generate a balance inside the Kamikaze contract by calling ```deposit()```
- Then, excecute the ```troyanHorse(levelContractAddress)``` function.
- That's it! The ```Force contract``` now has a balance of tokens!

### Predestination
This is a tricky one. But essentialy, the smart contract addresses on the blockchain can be generated by hashing the sender address and the current nonce of that address. If you can predict a contract address before it is deployed, you can simply send tokens to that address and when the contract is created it will collide with the existing tokens assigned to that address thus will have a balance greater than zero!
To predestinate our instance address we need two things: the sender address and the nonce.
- **Sender:** Because the creator of each instance is the level contract (0x22699e6AdD7159C3C385bf4d7e1C647ddB3a99ea)
- **Nonce:** We can create multiple consecutive instances and on Etherscan by going into the transaction details, go to the **"State"** tab and see the current nonce of each transaction sent by the level contract. This is quite tricky because we need to be quick. Because if there is another player that creates the instance we will be targeting, the tokens will be allocated to that level instance (and that player will have already won the level!).

Under the ```SolutionB07.ipynb``` there is a script that takes the level instance address and the last nonce and returns the new contract address.

By the time of this solution, the current nonce was **4192**. And the output of the program was **0xD8695d911Ed8b3d765523aFC324377dCe5799961**

More intresting are the timestamps of each transaction!
- Token Transfer (**May-12-2022 02:31:01 PM +UTC**): https://rinkeby.etherscan.io/tx/0xc57e275142f8adf898abfe3dddb711e8b23f3308c580face44b942ddfa0ff60a

- Contract Creation (**May-12-2022 02:32:01 PM +UTC**): https://rinkeby.etherscan.io/tx/0x2954b330db8d5e3ebc955c7222d019527e742ae7e785f36eccc241641f7f20a7

And that's it!
